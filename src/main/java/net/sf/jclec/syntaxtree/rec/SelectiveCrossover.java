package net.sf.jclec.syntaxtree.rec;

import net.sf.jclec.syntaxtree.IRecombineSyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;
import net.sf.jclec.util.random.IRandGen;

/**
 * Selective crossover.
 * 
 * @author Sebastian Ventura
 * @author Amelia Zafra 
 */

public class SelectiveCrossover implements IRecombineSyntaxTree 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -6447244450691681809L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */

	public SelectiveCrossover() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	/**
	 * This operator performs the following operations:
	 * 
	 * <ol>
	 * <li>Select a non terminal symbol at random (NT)</li>
	 * <li>Search NT in first parent</li> 
	 * </ol>
	 */
	@Override
	public void recombine(SyntaxTree ptree0, SyntaxTree ptree1, SyntaxTree stree0, SyntaxTree stree1, SyntaxTreeSchema schema, IRandGen randgen) 
	{
		boolean cond0, cond1;
		int p0_branchStart, p0_branchEnd;
		int p1_branchStart, p1_branchEnd;
		
		do
		{
			// Search symbol in first parent
			p0_branchStart = getNonTerminal(ptree0, randgen);
			// Set branch end 
			p0_branchEnd = ptree0.subTree(p0_branchStart);
			// Set branch depth (to check maximum size)
			int p0_branchDepth = ptree0.derivSize();
			int p0_swapBranch = 0;
			for(int i=p0_branchStart; i<p0_branchEnd; i++){
				if(ptree0.getNode(i).arity()!=0)
					p0_swapBranch++;
			}

			// Search symbol in second parent
			p1_branchStart = getNonTerminal(ptree1, randgen);
			// Set branch end 
			p1_branchEnd = ptree1.subTree(p1_branchStart);
			// Set branch depth (to check maximum size)
			int p1_branchDepth = ptree1.derivSize();
			int p1_swapBranch = 0;
			for(int i=p1_branchStart; i<p1_branchEnd; i++){
				if(ptree1.getNode(i).arity()!=0)
					p1_swapBranch++;
			}

			// Check maxTreeDepth condition
			cond0 = (p0_branchDepth - p0_swapBranch + p1_swapBranch > schema.getMaxDerivSize());
			cond1 = (p1_branchDepth - p1_swapBranch + p0_swapBranch > schema.getMaxDerivSize());
		}while(cond0 || cond1);

		// Perform crossover operation (first fragment)
		for (int i=0; i<p0_branchStart; i++) 
			stree0.addNode(ptree0.getNode(i).copy());
		for (int i=0; i<p1_branchStart; i++) 
			stree1.addNode(ptree1.getNode(i).copy());

		// Perform crossover operation (second fragment)
		for (int i=p0_branchStart; i<p0_branchEnd; i++) {
			stree1.addNode(ptree0.getNode(i).copy());			
		}
		for (int i=p1_branchStart; i<p1_branchEnd; i++) {
			stree0.addNode(ptree1.getNode(i).copy());		
		}

		// Perform crossover operation (third fragment)
		int p0_length = ptree0.size();
		for (int i=p0_branchEnd; i<p0_length; i++) 
			stree0.addNode(ptree0.getNode(i).copy());
		int p1_length = ptree1.size();
		for (int i=p1_branchEnd; i<p1_length; i++) 
			stree1.addNode(ptree1.getNode(i).copy());
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	private final int getNonTerminal(SyntaxTree tree, IRandGen randgen)
	{	
		// Tree length
		int treeLength = tree.size();
		// Generate a tree position at random
		int startPos = randgen.choose(0, treeLength);
		int actPos = startPos;

		for(int i=0; i < treeLength; i++) {
			// Update actPos
			actPos = (startPos+i)%treeLength;
			// Check symbols equality
			if(tree.getNode(actPos).getSymbol().equals("antecedent") || tree.getNode(actPos).getSymbol().equals("comparison"))
				return actPos;
		}

		System.err.println("Crossover getNonTerminal this is not supposed to happen");

		return -1;
	}
}
