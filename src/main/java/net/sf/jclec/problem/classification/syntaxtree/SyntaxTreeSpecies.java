package net.sf.jclec.problem.classification.syntaxtree;

import java.util.ArrayList;
import java.util.List;

import com.yahoo.labs.samoa.instances.Attribute;
import com.yahoo.labs.samoa.instances.Instances;
import com.yahoo.labs.samoa.instances.InstancesHeader;

import net.sf.jclec.problem.classification.blocks.AttributeValue;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfContinuousValues;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfDiscreteValues;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.TerminalNode;

public abstract class SyntaxTreeSpecies extends net.sf.jclec.syntaxtree.SyntaxTreeSpecies
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 1L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Genotype schema */

	protected SyntaxTreeSchema genotypeSchema;

	/** Dataset specification */

	protected InstancesHeader metadata;

	/** If categorical attributes exist, this variable is true*/

	protected boolean existCategoricalAttributes = false;

	/** If numerical attributes exist, this variable is true*/

	protected boolean existNumericalAttributes = false;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/** Empty constructor */

	public SyntaxTreeSpecies(){
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------------- Getting and setting properties
	/////////////////////////////////////////////////////////////////

	/**
	 * Access to genotype schema.
	 * 
	 * @return Genotype schema
	 */

	public SyntaxTreeSchema getGenotypeSchema() 
	{
		return genotypeSchema;
	}

	/**
	 * Get the metadata
	 *
	 * @return metadata
	 */

	public InstancesHeader getMetadata() 
	{
		return metadata;
	}

	/**
	 * Set the metadata
	 *
	 * @param metadata dataset specification
	 */

	public void setMetadata(InstancesHeader metadata) 
	{
		this.metadata = metadata;
	}

	/**
	 * Set the maximum number of derivations in trees.
	 * 
	 * @param maxDerivSize Maximum derivation size
	 */

	public void setMaxDerivSize(int maxDerivSize)
	{	
		genotypeSchema.setMaxDerivSize(maxDerivSize);
	}

	/**
	 * Get the maximum number of derivations in trees.
	 * 
	 * @return maxDerivSize Maximum derivation size
	 */

	public int getMaxDerivSize()
	{
		return genotypeSchema.getMaxDerivSize();
	}	

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	/**
	 *  Through the specification of the dataset, it will be generated the grammar to be used during execution
	 */

	public void setGrammar()
	{
		List<Attribute> inputAttributes = new ArrayList<Attribute>();

		//Obtains the input attributes
		for(int i = 0; i < metadata.numAttributes(); i++)
			if(i != metadata.classIndex())
				inputAttributes.add(metadata.attribute(i));

		List<TerminalNode> terminals = setTerminalSymbols(inputAttributes);
		List<NonTerminalNode> nonTerminals = setNonTerminalSymbols(inputAttributes);

		genotypeSchema = new SyntaxTreeSchema();
		genotypeSchema.setRootSymbol("antecedent");

		setTerminalNodes(terminals);
		setNonTerminalNodes(nonTerminals);			
	}

	public void adjustIntervals(Instances dataset)
	{
		attributeLoop: for(int i = 0; i < dataset.numAttributes()-1; i++)
		{
			if(dataset.attribute(i).isNumeric())
			{
				for(TerminalNode node : genotypeSchema.getTerminals())
				{
					if(node.getSymbol().equals("values"+dataset.attribute(i).name()))
					{
						double minValue = Double.MAX_VALUE;
						double maxValue = -Double.MAX_VALUE;
						
						for(int inst = 0; inst < dataset.size(); inst++)
						{
							if(dataset.instance(inst).value(i) < minValue)
								minValue = dataset.instance(inst).value(i);
							if(dataset.instance(inst).value(i) > maxValue)
								maxValue = dataset.instance(inst).value(i);
						}
						
						net.sf.jclec.util.range.Interval interval = ((RandomConstantOfContinuousValues) node.getCode()).getInterval();
						interval.setLeft(minValue);
						interval.setRight(maxValue);
						
						continue attributeLoop;
					}
				}
			}
		}
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Establishes the terminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of terminal symbols
	 */
	protected List<TerminalNode> setTerminalSymbols(List<Attribute> inputAttributes)
	{
		List<TerminalNode> terminals = new ArrayList<TerminalNode>();

		// Number of input attribute
		int numAttributes = inputAttributes.size();

		//Set terminal symbol
		for(int i = 0; i < numAttributes; i++)
		{
			//Creates a new terminal symbol and adds it to the list
			Attribute attribute = inputAttributes.get(i);
			TerminalNode term = new TerminalNode(attribute.name(), new AttributeValue());
			((AttributeValue) term.getCode()).setAttributeIndex(i);
			terminals.add(term);			

			//Checks the attribute type and assign the value type
			if(attribute.isNominal())
			{
				TerminalNode termValue = new TerminalNode("values"+attribute.name(), new RandomConstantOfDiscreteValues());
				((RandomConstantOfDiscreteValues) termValue.getCode()).setInterval(new net.sf.jclec.util.intset.Interval(0, attribute.numValues()-1, net.sf.jclec.util.intset.Closure.ClosedClosed));
				terminals.add(termValue);
				existCategoricalAttributes = true;
			} else if (attribute.isNumeric()) {
				TerminalNode termValue = new TerminalNode("values"+attribute.name(), new RandomConstantOfContinuousValues());
				((RandomConstantOfContinuousValues) termValue.getCode()).setInterval(new net.sf.jclec.util.range.Interval(-1.0, 1.0, net.sf.jclec.util.range.Closure.ClosedClosed));
				terminals.add(termValue);
				existNumericalAttributes = true;
			}
		}

		return terminals;
	}

	/**
	 * Set the terminal nodes
	 * 
	 * @param terminals list of terminal nodes
	 */

	private void setTerminalNodes(List<TerminalNode> terminals)
	{
		TerminalNode [] terminalsAux = new TerminalNode[terminals.size()];
		int i = 0;

		for(TerminalNode t: terminals)
			terminalsAux[i++] = (TerminalNode) t.copy();

		genotypeSchema.setTerminals(terminalsAux);
	}

	/**
	 * Set the non-terminal nodes
	 * 
	 * @param nonTerminals list of non terminal nodes
	 */

	private void setNonTerminalNodes(List<NonTerminalNode> nonTerminals)
	{
		NonTerminalNode [] nonTerminalsAux = new NonTerminalNode[nonTerminals.size()];
		int i = 0;

		for(NonTerminalNode t: nonTerminals)
			nonTerminalsAux[i++] = (NonTerminalNode) t.copy();

		genotypeSchema.setNonTerminals(nonTerminalsAux);
	}

	/**
	 * Establishes the nonterminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of nonterminal symbols
	 */

	protected abstract List<NonTerminalNode> setNonTerminalSymbols(List<Attribute> inputAttributes);

	/**
	 * {@inheritDoc}
	 */

	public abstract SyntaxTreeRuleIndividual createIndividual(SyntaxTree genotype);
}