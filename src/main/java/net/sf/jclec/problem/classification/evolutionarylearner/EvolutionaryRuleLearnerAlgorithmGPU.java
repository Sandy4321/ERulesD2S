package net.sf.jclec.problem.classification.evolutionarylearner;

import java.util.ArrayList;
import java.util.Collections;

import com.yahoo.labs.samoa.instances.Instances;
import com.yahoo.labs.samoa.instances.InstancesHeader;

import net.sf.jclec.IIndividual;
import net.sf.jclec.base.FilteredMutator;
import net.sf.jclec.base.FilteredRecombinator;
import net.sf.jclec.listener.PopulationReporter;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeRuleIndividual;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeSpecies;
import net.sf.jclec.selector.BettersSelector;
import net.sf.jclec.syntaxtree.SyntaxTreeCreator;
import net.sf.jclec.syntaxtree.SyntaxTreeMutator;
import net.sf.jclec.syntaxtree.SyntaxTreeRecombinator;
import net.sf.jclec.syntaxtree.rec.SelectiveCrossover;
import net.sf.jclec.util.random.RanecuFactory;

public class EvolutionaryRuleLearnerAlgorithmGPU extends EvolutionaryRuleLearnerAlgorithm 
{
	// ///////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	// ///////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -8711970425735016406L;

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////
	
	/**
	 * Empty (default) constructor
	 */

	public EvolutionaryRuleLearnerAlgorithmGPU() {
		super();
	}

	@Override
	public void addChunkData(Instances chunkInstances) {
		((RuleEvaluatorGPU) evaluator).addChunkData(chunkInstances);
		((SyntaxTreeSpecies) species).adjustIntervals(chunkInstances);
	}	

	@SuppressWarnings("unchecked")
	@Override
	public void contextualize(InstancesHeader context, int seed, int populationSize, int numberGenerations, int numberRulesClass, int numberWindows, double fadingFactor)
	{
		this.context = context;
		this.numberRulesClass = numberRulesClass;
		
		setPopulationSize(populationSize);
		setMaxOfGenerations(numberGenerations);

		System.out.println("\nDataset metadata");
		System.out.println("Attributes: " + context.numAttributes());
		System.out.println("Classes:    " + context.numClasses());
		System.out.println("populationSize " + populationSize);
		System.out.println("numberGenerations " + numberGenerations);
		System.out.println("numberRulesClass " + numberRulesClass);
		System.out.println("numberWindows " + numberWindows);
		System.out.println("fadingFactor " + fadingFactor);

		randGenFactory = new RanecuFactory();
		((RanecuFactory) randGenFactory).setSeed(seed);
		randGenFactory.createRandGen();

		recombinator = new FilteredRecombinator(this);
		recombinator.setDecorated(new SyntaxTreeRecombinator());
		recombinator.setRecProb(0.8);
		((SyntaxTreeRecombinator) recombinator.getDecorated()).setBaseOp(new SelectiveCrossover());

		mutator = new FilteredMutator(this);
		mutator.setDecorated(new SyntaxTreeMutator());
		mutator.setMutProb(0.2);
		((SyntaxTreeMutator) mutator.getDecorated()).setBaseOp(new RuleMutator(context));

		species = new RuleSyntaxTreeSpecies();
		evaluator = new RuleEvaluatorGPU();
		((RuleEvaluatorGPU) evaluator).setNumberWindows(numberWindows);
		((RuleEvaluatorGPU) evaluator).setFadingFactor(fadingFactor);
		((RuleEvaluatorGPU) evaluator).contextualize(this);
		provider = new SyntaxTreeCreator();
		provider.contextualize(this);

		bettersSelector = new BettersSelector(this);

		PopulationReporter listener = new PopulationReporter();
		listener.setReportFrequency(50);
		listeners.add(listener);

		// Establishes the metadata for the species
		((RuleSyntaxTreeSpecies) species).setMetadata(context);
		((RuleSyntaxTreeSpecies) species).setGrammar();
		((RuleSyntaxTreeSpecies) species).setMaxDerivSize(30);

		bset = new ArrayList[context.numClasses()];
		cset = new ArrayList[context.numClasses()];
		mset = new ArrayList[context.numClasses()];
		solutions = new ArrayList[context.numClasses()];
		newsolutions = new ArrayList[context.numClasses()];
		
		for(int i = 0; i < context.numClasses(); i++)
		{
			solutions[i] = new ArrayList<IIndividual>();
			newsolutions[i] = new ArrayList<IIndividual>();
		}
	}

	@Override
	protected void doInit() 
	{
		for(int i = 0; i < context.numClasses(); i++) 
		{
			bset[i] = provider.provide(populationSize);

			if(solutions[i].size() > 0)
			{
				solutions[i].get(iteration).setFitness(null);
				bset[i].add(solutions[i].get(iteration));
			}

			for(IIndividual ind : bset[i]) // DO ALWAYS BEFORE EVALUATION
				((SyntaxTreeRuleIndividual) ind).getPhenotype().setConsequent(i);
		}

		((RuleEvaluatorGPU) evaluator).evaluateGPU(bset);
	}

	@Override
	protected void doGeneration() 
	{
		for(int i = 0; i < context.numClasses(); i++)
		{
			Collections.shuffle(bset[i]);
			// Recombine parents
			rset = recombinator.recombine(bset[i]);
			// Add non-recombined inds
			rset.addAll(recombinator.getSterile());
			// Mutate filtered inds
			mset[i] = mutator.mutate(rset);
			// Add non-mutated inds
			mset[i].addAll(mutator.getSterile());
			cset[i] = mset[i];

			for(IIndividual ind : cset[i]) // DO ALWAYS BEFORE EVALUATION
				((SyntaxTreeRuleIndividual) ind).getPhenotype().setConsequent(i);
		}

		((RuleEvaluatorGPU) evaluator).evaluateGPU(cset);
	}
}