package net.sf.jclec.problem.classification.evolutionarylearner;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.yahoo.labs.samoa.instances.Instances;
import com.yahoo.labs.samoa.instances.InstancesHeader;

import net.sf.jclec.IIndividual;
import net.sf.jclec.algorithm.PopulationAlgorithm;
import net.sf.jclec.base.FilteredMutator;
import net.sf.jclec.base.FilteredRecombinator;
import net.sf.jclec.listener.PopulationReporter;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeRuleIndividual;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeSpecies;
import net.sf.jclec.selector.BettersSelector;
import net.sf.jclec.syntaxtree.SyntaxTreeCreator;
import net.sf.jclec.syntaxtree.SyntaxTreeMutator;
import net.sf.jclec.syntaxtree.SyntaxTreeRecombinator;
import net.sf.jclec.syntaxtree.rec.SelectiveCrossover;
import net.sf.jclec.util.random.RanecuFactory;

public class EvolutionaryRuleLearnerAlgorithm extends PopulationAlgorithm 
{
	// ///////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	// ///////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -8711970425735016406L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////

	protected BettersSelector bettersSelector;

	protected FilteredRecombinator recombinator;

	protected FilteredMutator mutator;

	protected InstancesHeader context;

	protected List<IIndividual>[] bset;

	protected List<IIndividual>[] cset;
	
	protected List<IIndividual>[] mset;

	protected List<IIndividual>[] solutions;

	protected List<IIndividual>[] newsolutions;

	protected int iteration = 0;

	protected int numberRulesClass;

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */

	public EvolutionaryRuleLearnerAlgorithm() {
		super();
	}

	public InstancesHeader getContext() {
		return context;
	}

	public List<IIndividual>[] getSolutions() {
		return solutions;
	}

	public void addChunkData(Instances chunkInstances) {
		((RuleEvaluator) evaluator).addChunkData(chunkInstances);
		((SyntaxTreeSpecies) species).adjustIntervals(chunkInstances);
	}	

	@SuppressWarnings("unchecked")
	public void contextualize(InstancesHeader context, int seed, int populationSize, int numberGenerations, int numberRulesClass, int numberWindows, double fadingFactor)
	{
		this.context = context;
		this.numberRulesClass = numberRulesClass;

		setPopulationSize(populationSize);
		setMaxOfGenerations(numberGenerations);

		System.out.println("\nDataset metadata");
		System.out.println("Attributes: " + context.numAttributes());
		System.out.println("Classes:    " + context.numClasses());
		System.out.println("populationSize " + populationSize);
		System.out.println("numberGenerations " + numberGenerations);
		System.out.println("numberRulesClass " + numberRulesClass);
		System.out.println("numberWindows " + numberWindows);
		System.out.println("fadingFactor " + fadingFactor);

		randGenFactory = new RanecuFactory();
		((RanecuFactory) randGenFactory).setSeed(seed);
		randGenFactory.createRandGen();

		recombinator = new FilteredRecombinator(this);
		recombinator.setDecorated(new SyntaxTreeRecombinator());
		recombinator.setRecProb(0.8);
		((SyntaxTreeRecombinator) recombinator.getDecorated()).setBaseOp(new SelectiveCrossover());

		mutator = new FilteredMutator(this);
		mutator.setDecorated(new SyntaxTreeMutator());
		mutator.setMutProb(0.2);
		((SyntaxTreeMutator) mutator.getDecorated()).setBaseOp(new RuleMutator(context));

		species = new RuleSyntaxTreeSpecies();
		evaluator = new RuleEvaluator();
		((RuleEvaluator) evaluator).setNumberWindows(numberWindows);
		((RuleEvaluator) evaluator).setFadingFactor(fadingFactor);
		provider = new SyntaxTreeCreator();
		provider.contextualize(this);

		bettersSelector = new BettersSelector(this);

		PopulationReporter listener = new PopulationReporter();
		listener.setReportFrequency(50);
		listeners.add(listener);

		// Establishes the metadata for the species
		((RuleSyntaxTreeSpecies) species).setMetadata(context);
		((RuleSyntaxTreeSpecies) species).setGrammar();
		((RuleSyntaxTreeSpecies) species).setMaxDerivSize(30);

		bset = new ArrayList[context.numClasses()];
		cset = new ArrayList[context.numClasses()];
		mset = new ArrayList[context.numClasses()];
		solutions = new ArrayList[context.numClasses()];
		newsolutions = new ArrayList[context.numClasses()];
		
		for(int i = 0; i < context.numClasses(); i++)
		{
			solutions[i] = new ArrayList<IIndividual>();
			newsolutions[i] = new ArrayList<IIndividual>();
		}
	}

	@Override
	protected void doInit() 
	{
		for(int i = 0; i < context.numClasses(); i++) 
		{
			bset[i] = provider.provide(populationSize);

			if(solutions[i].size() > 0)
			{
				solutions[i].get(iteration).setFitness(null);
				bset[i].add(solutions[i].get(iteration));
			}
			
			for(IIndividual ind : bset[i])
				((SyntaxTreeRuleIndividual) ind).getPhenotype().setConsequent(i);

			evaluator.evaluate(bset[i]);
		}
	}

	@Override
	protected void doSelection() {
		// do nothing
	}

	@Override
	protected void doGeneration() 
	{
		for(int i = 0; i < context.numClasses(); i++)
		{
			Collections.shuffle(bset[i]);
			// Recombine parents
			rset = recombinator.recombine(bset[i]);
			// Add non-recombined inds
			rset.addAll(recombinator.getSterile());
			// Mutate filtered inds
			mset[i] = mutator.mutate(rset);
			// Add non-mutated inds
			mset[i].addAll(mutator.getSterile());
			
			for(IIndividual ind : mset[i])
				((SyntaxTreeRuleIndividual) ind).getPhenotype().setConsequent(i);

			evaluator.evaluate(mset[i]);

			cset[i] = mset[i];
		}
	}

	@Override
	protected void doReplacement() {
		// do nothing
	}

	@Override
	protected void doUpdate()
	{
		for(int i = 0; i < context.numClasses(); i++)
		{
			List<IIndividual> newpopulation = new ArrayList<IIndividual>();

			for(IIndividual ind : bset[i])
				if(!newpopulation.contains(ind))
					newpopulation.add(ind);

			for(IIndividual ind : cset[i])
				if(!newpopulation.contains(ind))
					newpopulation.add(ind);			

			bset[i] = bettersSelector.select(newpopulation, populationSize);

			for(IIndividual ind : bset[i])
				((SyntaxTreeRuleIndividual) ind).getPhenotype().setConsequent(i);
		}
	}

	protected void doControl() 
	{
		if (generation == maxOfGenerations) 
		{
			generation = 0;

			for(int i = 0; i < context.numClasses(); i++)
				newsolutions[i].add(bset[i].get(0));

			iteration++;

			if(iteration == numberRulesClass)
			{
				iteration = 0;

				for(int i = 0; i < context.numClasses(); i++)
				{
					solutions[i].clear();
					solutions[i].addAll(newsolutions[i]);
					newsolutions[i].clear();
				}

				state = FINISHED;
			}
			else
				doInit();
		}
	}
}