package net.sf.jclec.problem.classification.evolutionarylearner;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.commons.lang.ArrayUtils;

import com.yahoo.labs.samoa.instances.Instances;

import net.sf.jclec.IIndividual;
import net.sf.jclec.exprtree.ExprTree;
import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeRuleIndividual;

public class RuleEvaluatorGPU extends RuleEvaluator
{
	/////////////////////////////////////////////////////////////////
	//--------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 3613350191235561000L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////

	private List<IIndividual> individuals;

	private Instances dataset;

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////

	public RuleEvaluatorGPU() {
		super();
	}

	public native void allocateMemoryGPU(int maximumNumberRules, int maximumNumberInstances, int numberAttributes, int numberClasses, RuleEvaluatorGPU object);
	public native void copyDatasetGPU(int numberInstances, RuleEvaluatorGPU object);
	public native void evaluateGPU(int numberRules, RuleEvaluatorGPU object);
	public native void releaseGPU();

	public void contextualize(EvolutionaryRuleLearnerAlgorithmGPU algorithm)
	{
		individuals = new ArrayList<IIndividual>();

		try {
			System.loadLibrary("ERulesD2SGPU");
		} catch (Exception e) {
			System.err.println("Can't load ERulesD2SGPU library. Please make sure to include GPU library path");
			System.exit(0);
		}

		int maximumNumberRules = (algorithm.getPopulationSize() + 1) * algorithm.getContext().numClasses();
		int maximumNumberInstances = 32768; // maximum number of instances in a given time
		int numberAttributes = algorithm.getContext().numAttributes();
		int numberClasses = algorithm.getContext().numClasses();

		allocateMemoryGPU(maximumNumberRules, maximumNumberInstances, numberAttributes, numberClasses, this);
	}

	@Override
	public void addChunkData(Instances chunkInstances) {
		super.addChunkData(chunkInstances);

		dataset = new Instances(chunkInstances, 0);

		for(Instances window : datasets)
			if(window != null)
				for(int i = 0; i < window.size(); i++)
					dataset.add(window.get(i));

		copyDatasetGPU(dataset.size(), this);
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------ Overwriting AbstractEvaluator methods
	// ///////////////////////////////////////////////////////////////

	/**
	 * Evaluates the individual and compute it fitness 
	 * 
	 * @param individual Individual to evaluate
	 */

	public void evaluateGPU(List<IIndividual>[] bset)
	{
		individuals.clear();

		for(List<IIndividual> list : bset)
			for(IIndividual ind : list)
				if(ind.getFitness() == null)
					individuals.add(ind);

		evaluateGPU(individuals.size(), this);
	}

	public void setFitness(int individual, float fitness)
	{
		individuals.get(individual).setFitness(new SimpleValueFitness(fitness));
	}

	public float getValue(int instance, int attribute)
	{
		return (float) dataset.instance(instance).value(attribute);
	}

	public int getConsequent(int individual)
	{
		return (int) ((SyntaxTreeRuleIndividual) individuals.get(individual)).getPhenotype().getConsequent();
	}

	public float[] getAntecedent(int individual)
	{
		ExprTree ruleTree = ((SyntaxTreeRuleIndividual) individuals.get(individual)).getPhenotype().getAntecedent();

		List<Float> antecedent = new ArrayList<Float>();
		List<Float> temp = new ArrayList<Float>();

		for (int i = ruleTree.size()-1; i >= 0; i--)
		{
			List<Float> primitive = ruleTree.getBlock(i).toGPUcode();

			if(primitive.size() == 1)
			{
				temp.add(primitive.get(0));
			}
			else
			{
				if(primitive.get(1) == 1.0f)
				{
					temp.add(primitive.get(0));

					Collections.reverse(temp);

					antecedent.addAll(temp);

					temp.clear();
				}
				else
				{
					antecedent.add(primitive.get(0));
				}
			}
		}

		antecedent.add(0, (float) antecedent.size());

		return ArrayUtils.toPrimitive(antecedent.toArray(new Float[0]), 0.0F);
	}
}