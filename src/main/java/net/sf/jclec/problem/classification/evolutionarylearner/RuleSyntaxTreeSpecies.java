package net.sf.jclec.problem.classification.evolutionarylearner;

import java.util.ArrayList;
import java.util.List;

import com.yahoo.labs.samoa.instances.Attribute;

import net.sf.jclec.problem.classification.blocks.And;
import net.sf.jclec.problem.classification.blocks.Equal;
import net.sf.jclec.problem.classification.blocks.Greater;
import net.sf.jclec.problem.classification.blocks.Less;
import net.sf.jclec.problem.classification.blocks.Not;
import net.sf.jclec.problem.classification.blocks.NotEqual;
import net.sf.jclec.problem.classification.blocks.Or;
import net.sf.jclec.problem.classification.crisprule.CrispRule;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeRuleIndividual;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeSpecies;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.TerminalNode;

public class RuleSyntaxTreeSpecies extends SyntaxTreeSpecies
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 1L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	public RuleSyntaxTreeSpecies() {
		super();
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Establishes the terminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of terminal symbols
	 */

	protected List<TerminalNode> setTerminalSymbols(List<Attribute> inputAttributes)
	{
		List<TerminalNode> terminals = super.setTerminalSymbols(inputAttributes);

		if(existCategoricalAttributes) {
			terminals.add(new TerminalNode("=", new Equal()));
			terminals.add(new TerminalNode("!=", new NotEqual()));
		}

		if(existNumericalAttributes) {
			terminals.add(new TerminalNode(">", new Greater()));
			terminals.add(new TerminalNode("<", new Less()));
		}

		terminals.add(new TerminalNode("AND", new And()));
		terminals.add(new TerminalNode("OR", new Or()));
		terminals.add(new TerminalNode("NOT", new Not()));

		return terminals;
	}

	/**
	 * Establishes the nonterminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of nonterminal symbols
	 */

	protected List<NonTerminalNode> setNonTerminalSymbols(List<Attribute> inputAttributes)
	{
		List<NonTerminalNode> nonTerminals = new ArrayList<NonTerminalNode>();

		// Number of input attribute
		int numAttributes = inputAttributes.size();

		//Set fixed non terminal symbols		
		nonTerminals.add(new NonTerminalNode("antecedent", new String [] {"comparison"}));
		nonTerminals.add(new NonTerminalNode("antecedent", new String [] {"AND", "antecedent", "comparison"}));
		nonTerminals.add(new NonTerminalNode("antecedent", new String [] {"OR",  "antecedent", "comparison"}));
		nonTerminals.add(new NonTerminalNode("antecedent", new String [] {"NOT",  "antecedent"}));

		if(existCategoricalAttributes) 
		{
			nonTerminals.add(new NonTerminalNode("comparison", new String [] {"categorical_comparator", "categorical_attribute_comparison"}));
			nonTerminals.add(new NonTerminalNode("categorical_comparator", new String [] {"="}));
			nonTerminals.add(new NonTerminalNode("categorical_comparator", new String [] {"!="}));
		}
		
		if(existNumericalAttributes) 
		{
			nonTerminals.add(new NonTerminalNode("comparison", new String [] {"numerical_comparator", "numerical_attribute_comparison"}));
			nonTerminals.add(new NonTerminalNode("numerical_comparator", new String [] {">"}));
			nonTerminals.add(new NonTerminalNode("numerical_comparator", new String [] {"<"}));
		}

		// Set non terminal symbols
		for(int i=0; i<numAttributes; i++)
		{
			Attribute attribute = inputAttributes.get(i);
			String [] attr = new String [] {attribute.name(), "values"+attribute.name()};

			if(attribute.isNumeric())
				nonTerminals.add(new NonTerminalNode("numerical_attribute_comparison", attr));
			else if(attribute.isNominal())
				nonTerminals.add(new NonTerminalNode("categorical_attribute_comparison", attr));
		}

		return nonTerminals;
	}

	@Override
	public SyntaxTreeRuleIndividual createIndividual(SyntaxTree genotype) {
		return new SyntaxTreeRuleIndividual(genotype, new CrispRule(genotype.getExprTree()));
	}
}